source ~/.fzf.bash

# DEFAULTS
# ---------
export FZF_COMPLETION_TRIGGER='**'
export FD_OPTIONS='--follow --exclude .git --exclude node_modules --exclude Library/Caches/ --exclude Library/Containers/'
export FZF_DEFAULT_COMMAND="git ls-files --cached --others --exclude-standard 2>/dev/null | fd $FD_OPTIONS"
export FZF_DEFAULT_OPTS="--no-mouse --height 50% -1 --reverse --multi --preview='[[ \$(file --mime {}) =~ binary ]] && echo {} is a binary file || (bat --style=numbers --color=always {} || cat {}) 2>/dev/null | head -30\' --bind='f3:execute(bat --style=numbers {} || less -f {}),ctrl-p:toggle-preview,ctrl-d:half-page-down,ctrl-u:half-page-up,ctrl-a:select-all+accept,ctrl-y:execute-silent(echo {+} | pbcopy)'"
export FZF_ALT_C_COMMAND="fd --type d $FD_OPTIONS"
export FZF_ALT_C_OPTS="--preview 'fd . {} | as-tree --color always' --bind='ctrl-i:reload($FZF_ALT_C_COMMAND),ctrl-h:reload($FZF_ALT_C_COMMAND --no-ignore)'"
export FZF_CTRL_R_OPTS="--preview-window down:3:hidden:wrap"
# --select-1 automatically selects the item if there's only one so that you don't have to press enter key. Likewise, --exit-0 automatically exits when the list is empty
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_CTRL_T_OPTS="--select-1 --exit-0 --preview-window right:70%:hidden:wrap" 

bind '"\er": redraw-current-line'
bind '"\C-g\C-f": "$(gf)\e\C-e\er"'
bind '"\C-g\C-b": "$(gb)\e\C-e\er"'
bind '"\C-g\C-t": "$(gt)\e\C-e\er"'
bind '"\C-g\C-h": "$(gh)\e\C-e\er"'
bind '"\C-g\C-r": "$(gr)\e\C-e\er"'
# C-x C-r to directly execute a command from history
bind "$(bind -s | grep '^"\\C-r"' | sed 's/"/"\\C-x/' | sed 's/"$/\\C-m"/')"


# FUNCTIONS
# ----------

# Use fd (https://github.com/sharkdp/fd) instead of the default find command for listing path candidates.
# - The first argument to the function ($1) is the base path to start traversal
# - See the source code (completion.{bash,zsh}) for the details.
_fzf_compgen_path() {
  fd --hidden $FD_OPTIONS . "$1"
}

# Use fd to generate the list for directory completion
_fzf_compgen_dir() {
  fd --type d $FD_OPTIONS . "$1"
}

fzf_down() {
    fzf --height 50% "$@" --border
}

is_in_git_repo() {
    git rev-parse HEAD > /dev/null 2>&1
}

gf() {
    is_in_git_repo || return
    git -c color.status=always status --short |
    fzf_down -m --ansi --nth 2..,.. \
        --preview 'git diff --color=always -- {-1}' |
    cut -c4- | sed 's/.* -> //'
}

diff() {
    is_in_git_repo || return
    git diff $@ --name-only |
      xargs -I '{}' realpath --relative-to=. $(git rev-parse --show-toplevel)/'{}' |
      fzf_down -m --ansi --nth 2..,.. --preview "git diff $@ --color=always -- {-1}"
}

gb() {
    is_in_git_repo || return
    git branch -a --color=always | grep -v '/HEAD\s' | sort |
    fzf_down --ansi --multi --tac --preview-window right:70% \
        --preview 'git log --oneline --graph --date=short --color=always --pretty="format:%C(auto)%cd %h%d %s" $(sed s/^..// <<< {} | cut -d" " -f1) | head -'$LINES |
    sed 's/^..//' | cut -d' ' -f1 |
    sed 's#^remotes/##'
}

gt() {
    is_in_git_repo || return
    git tag --sort -version:refname |
    fzf_down --multi --preview-window right:70% \
        --preview 'git show --color=always {} | head -'$LINES
}

gh() {
    is_in_git_repo || return
    git log --date=short --format="%C(green)%C(bold)%cd %C(auto)%h%d %s (%an)" --graph --color=always |
    fzf_down --ansi --no-sort --reverse --multi --bind 'ctrl-s:toggle-sort' \
        --header 'Press CTRL-S to toggle sort' \
        --preview 'grep -o "[a-f0-9]\{7,\}" <<< {} | xargs git show --color=always | head -'$LINES |
    grep -o "[a-f0-9]\{7,\}"
}

gr() {
    is_in_git_repo || return
    git remote -v | awk '{print $1 "\t" $2}' | uniq |
    fzf_down --tac \
        --preview 'git log --oneline --graph --date=short --pretty="format:%C(auto)%cd %h%d %s" -n200 {1}'
}

function cdi() {
    if [[ "$#" != 0 ]]; then
        builtin cd "$@";
        return
    fi
    while true; do
        local lsd=$(echo ".." && ls -p | grep '/$' | sed 's;/$;;')
        local dir="$(printf '%s\n' "${lsd[@]}" |
            fzf --reverse --preview '
                __cd_nxt="$(echo {})";
                __cd_path="$(echo $(pwd)/${__cd_nxt} | sed "s;//;/;")";
                echo $__cd_path;
                echo;
                ls "${__cd_path}";
        ')"
        [[ ${#dir} != 0 ]] || return 0
        builtin cd "$dir" &> /dev/null
    done
}

function fkill() {
    local pid 
    if [ "$UID" != "0" ]; then
        pid=$(ps -f -u $UID | sed 1d | fzf -m | awk '{print $2}')
    else
        pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')
    fi  

    if [ "x$pid" != "x" ]
    then
        echo $pid | xargs kill -${1:-9}
    fi  
}

function fman() {
    man -k . | fzf --prompt='Man> ' | awk 'BEGIN{ FS="\\(|\\)" } {print $2, $1}' | xargs -L 1 man
}

function fopen() {
    fd ${2:-.} ${3:-$HOME} | fzf_down -m --print0 | xargs -0 ${1:-subl}
}

